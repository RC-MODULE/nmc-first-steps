global __main: label;     // объявление глобальной метки.
	
data ".MyData"            // секция инициализированных данных
	// начальное значение для заполнения массива
	AA: long = 100000000hl;
	// инкремент для первого цикла
	BB: long = 200000002hl;
	// инкремент для второго цикла
	CC: long = 4000000040hl;
end ".MyData";	
	
nobits ".MyData1"         // секция неинициализированных данных.
    .align;               // псевдокоманда для выравнивания начала массива по 
                          // чётному адресу.
    // массив из 256-ти 32-х разрядных элементов, который будет заполнен возрастающими 
    // значениями от 0 до 255
    global A: word[256];
end ".MyData1";	
	
begin ".textAAA"          // начало секции кода.
<__main>	
    ar0     = AA;         // в ar0 загружается адрес АА (АА = 100000000hl)
    ar4     = BB;         // в ar4 загружается адрес ВВ (ВВ = 200000002hl)
    ar1,gr1 = A;          // в ar1 и в gr1 загружается адрес буфера A 
    gr2     = 31;         // счетчик цикла
		
    nb1 = 80000000h;      // разбиение по два 32-х разрядных элемента в векторе
    wtw;                  // копирование содержимого теневого регистра nb1 в 
                          // рабочий nb2
		
    // в ram записывается инкремент, который будет добавляться в цикле к текущему
    // значению afifo для получения новых значений заполнителя.
    rep 1 ram = [ar4];
    // в векторный процессор заносится первое значение заполнителя.
    rep 1 data = [ar0] with data;
	
    gr2--;                // установка флагов для первого вхождения в цикл.
<Loop>	
	if > delayed goto Loop with gr2--;
    // заполняются первые 64 элемента выходного массива
    rep 1 [ar1++] = afifo with afifo + ram;
	nul;
	

    rep 1 [ar1++] = afifo;// выгрузка в память последнего значения из afifo
    ar1 = gr1;            // возвращение в начало массива
		
    ar0 = CC;             // в ar0 загружается адрес CC (CC = 4000000040hl)
		
    // в ram записывается инкремент, который будет добавляться в цикле к текущему
    // значению afifo для получения новых значений заполнителя.
    rep 32 ram = [ar0];
    // в векторный процессор заносятся первые значения заполнителя из А.
	gr2 = 3;              // счётчик для второго цикла
	ar2 = gr1 with gr2--; // ar2 устанавливается в начало массива и установка флагов для контроля обнуления счетчика
    rep 32 data = [ar2++] with data;
	
<Loop1>	
	if > delayed goto Loop1 with gr2--;
    // массив A заполняется возрастающими значениями
    // за один цикл обрабатываются 64 32-разрядных элемента.
    rep 32 [ar1++] = afifo with afifo + ram;
	nul;
	
    // последние 64 элемента массива сохраняются в памяти
    rep 32 [ar1++] = afifo;
	
	return;	
end ".textAAA";           // признак окончания секции кода.
