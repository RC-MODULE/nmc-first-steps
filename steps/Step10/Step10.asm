global _AddSaturate: label;
data ".data"	
	Masks: long[24] = 
       (0000000000000001hl,      // матрица дл€ первого прохода
        0000000000010000hl,	
        0000000100000000hl,	
        0001000000000000hl,	
        0000000000000000hl dup 4,	
        	
        0000000000000001hl,      // матрица дл€ второго прохода
        0000000000000100hl,	
        0000000000010000hl,	
        0000000001000000hl,	
        	
        0000000000000000hl dup 4,// матрица дл€ третьего 
        0000000000000001hl,      // прохода
        0000000000010000hl,	
        0000000100000000hl,	
        0001000000000000hl,	
        	
        0000000100000000hl,      // матрица дл€ четвЄртого 
        0000010000000000hl,      // прохода
        0001000000000000hl,	
        0100000000000000hl);	
end ".data";	
begin ".text"	
<_AddSaturate>	
	ar5 = sp - 2;	
	push ar0, gr0;	
	push ar1, gr1;	
	push ar4, gr4;	
	push ar6, gr6;	
		
	gr0 = [--ar5];    // первый входной параметр (SRC1)
	gr1 = [--ar5];    // второй входной параметр (SRC2)
	ar4 = [--ar5];    // третий входной параметр (DST)
		
	ar0 = gr0;	
	ar1 = gr1;	
		
	ar6 = Masks;      // адрес буфера, хран€щего весовые коэффициенты
		
	f1cr = 0FF80FF80h;// конфигураци€ арифметической функции активации
		
    // определение конфигурации рабочей матрицы дл€ первого шага вычислений
    nb1 = 80008000h;  // 4 столбца
    sb  = 03030303h;  // 8 строк
		
    // сразу все весовые коэффициенты (дл€ четырЄх матриц) загружаютс€ в wfifo,
    // а в теневую матрицу передаЄтс€ только 8 слов в соответствии со значени€ми sb и nb1
    rep 24 wfifo = [ar6++],ftw, wtw;
	
    // поскольку рабоча€ матрица уже загружена, можно приступить к загрузке теневой 
    // матрицы новой порцией весовых коэффициентов и определить новую конфигурацию.
    nb1 = 80808080h;
    sb  = 00030003h;
    // вычислени€ на рабочей матрице выполн€ютс€ параллельно с загрузкой теневой,
    // следующие две инструкции выполн€ют преобразование разр€дностей и поэлементное 
    // сложение входных векторов.
    rep 32 data = [ar0++], ftw with vsum , data, 0;
    rep 32 data = [ar1++] with vsum , data, afifo;
	
	wtw;	          // копирование теневой матрицы в рабочую
	nb1 = 80008000h;
	sb  = 03030303h;
    // выполнение арифметической активации с последующим преобразованием разр€дности
    rep 32 ftw with vsum , activate afifo, 0;
	
    // возвращение к началу исходных массивов дл€ обработки вторых половин векторов
    ar0 = gr0;
    ar1 = gr1;
    // сохранение результатов первого шага преобразовани€ в ram
    rep 32 [ar4],ram = afifo;
    wtw;
	
    // второй шаг вычислений полностью повтор€ет первый, отличие в весах матрицы.
    nb1 = 80808080h;
    sb  = 00030003h;
	
    rep 32 data = [ar0++], ftw with vsum , data, 0;
    rep 32 data = [ar1++] with vsum , data, afifo;
	
    wtw;	
    // инструкци€ активируют данные, преобразует размерность и складывает с 
    // результатом первого прохода.  
    rep 32 with vsum , activate afifo, ram;
	
    // результат вычислений сохран€етс€ в пам€ти.
    rep 32 [ar4++] = afifo;
	
    pop ar6, gr6;	  // восстановление регистровых пар из стека
    pop ar4, gr4;	
    pop ar1, gr1;	
    pop ar0, gr0;	
    return;	
		
end ".text";	
